---
title: "Einf√ºhrung in R & RStudio ‚Äì Tag 2"
subtitle: "Fehlende Werte, Umkodieren & Workflows"
format:
  html:
    toc: true
    toc-title: "Tag 2 ‚Äì Inhalte"
    toc-location: left
    toc-depth: 2

    
sidebar: workshop1
---

Willkommen zur√ºck üëã  
Wir starten mit einem kurzen Recap von Tag 1 und kl√§ren offene Fragen.

# Recap - Tag 1

Wir haben im ersten Teil des Workshops gelernt, wie RStudio aufgebaut ist und funktioniert. Wir kennen nun die wichtigsten Grundlagen und k√∂nnen diese heute weiter **vertiefen und festigen**.

::: callout-tip
# **Recap-Fragen**
- Was ist ein Data Frame?
- Was macht `select()` vs. `filter()`?
- Wof√ºr nutzen wir Pipes (`|>`)?
:::

::: callout-note
# **Merksatz**

R ist eine **Programmiersprache** ‚Äì und wie jede Sprache lernt man sie  
durch **regelm√§√üige Nutzung**.

Fehler zu machen ist v√∂llig normal (auch wenn es manchmal frustrierend ist).  
F√ºr fast jedes Problem gibt es **eine L√∂sung, eine Erkl√§rung oder ein Paket** üòä
:::

___

# Umkodieren

In der Datenanalyse arbeiten wir h√§ufig mit Variablen,  
deren Werte **nicht direkt so vorliegen**, wie wir sie f√ºr eine Auswertung ben√∂tigen.

**Umkodieren** bedeutet, Werte oder Kategorien gezielt zu ver√§ndern oder neu zusammenzufassen, damit Variablen
- **inhaltlich korrekt** interpretiert werden k√∂nnen und
- **f√ºr Analysen** (z. B. Gruppenvergleiche, Skalenbildung) besser nutzbar sind.

Beim Umkodieren k√∂nnen zum Beispiel:

- Kategorien zusammengefasst werden  
  (z. B. mehrere Bildungsabschl√ºsse ‚Üí ‚Äûniedrig / mittel / hoch‚Äú)
- Werte umgedreht werden  
  (z. B. hohe Werte = geringe Zustimmung)
- neue Variablen aus bestehenden gebildet werden  
  (z. B. Summen- oder Skalenwerte) **‚Üí** das kennen wir schon!

::: callout-tip
# **Warum ist Umkodieren wichtig?**

Rohdaten sind selten sofort ‚Äûanalysefertig‚Äú.  
Durch Umkodieren stellen wir sicher,  
dass unsere Variablen **inhaltlich korrekt** interpretiert  
und **vergleichbar** ausgewertet werden k√∂nnen. Umkodierung ist daher ein wichtiger **Bestandteil der Datenaufbereitung** und **wichtig** f√ºr die sp√§teren Analysen!
:::

Im Folgenden sehen wir typische Beispiele f√ºr Umkodierungen  
und setzen sie direkt mit R um.

## Umkodieren invertierter Items

In Frageb√∂gen kommen h√§ufig invertierte Items vor. Das bedeutet: Hohe Werte dr√ºcken geringe Zustimmung aus ‚Äì oder umgekehrt.

Damit alle Items in dieselbe Richtung zeigen, m√ºssen invertierte Items umkodiert werden.

### Beispiel 

Die Items `hs04` bis `hs07 und hs09` Fragen die mentale Gesundheit in den letzten vier Wochen ab:

|**Variable**|**Inhalt**|**Skalierung**|
|----|----|----|
|hs04|"Hetze, unter Zeitdruck"| 1 = "Immer" bis 5 = "Nie"|
|hs05|"Niedergeschlage"| 1 = "Immer" bis 5 = "Nie"|
|hs06|"Ruhig, Ausgeglichen"| 1 = "Immer" bis 5 = "Nie"|
|hs07|"Jede menge Energie"| 1 = "Immer" bis 5 = "Nie"|
|hs09|"Einsam"|1 = "Immer" bis 5 = "Nie"|

Wir wir sehen, sind einige Items invertiert formuliert. W√ºrden wir daraus, eine Skala bilden bspw. **Disstress**, k√∂nnten wir mit dem `mutate()`Befehl, keine ad√§quate Skala bilden.

Wir m√ºssen also entscheiden, was nun **hohe Werte und was niedrige Werte** darstellen sollen. Damit es intuitiver ist, wollen wir nun die **Variablen `hs04`, `hs05` und `hs09`umkodieren**, damit sp√§ter es hoher Wert auf der Skala **"viel Disstress"** darstellen kann.

Doch bevor wir Anfangen, laden wir zun√§chst unseren Datensatz und die Pakte wieder ein, bzw. haben diese schon im Environment!

```{r}
#| echo: true
#| warning: false

library(tidyverse)

df_csv <- read_csv("assets/data/datensatz_workshop.csv")

head(df_csv, 10)
```

Zum besseren Verst√§ndnis verkleinern wir erstmal unseren Datensatz: Erstelle den Datensatz `df_diss` mit nur den Items die wir ben√∂tigen.

:::{.callout-tip collapse="true"}
# L√∂sung

```{r}

df_diss <- df_csv |>
select(hs04,hs05,hs06,hs07,hs09)

head(df_diss, 10)

```

:::

Nun k√∂nnen wir in diesem neuen Datensatz, getrennt von den Rohdaten, √ºben!

:::{.panel-tabset}

# Alternative 1

```{r}
#| echo: true

# jede Variable einzeln und manuell

df_diss$hs04_inv <- 6 - df_diss$hs04

head(df_diss$hs04,10)

head(df_diss$hs04_inv,10)
```
:::{.callout-tip collapse="true"}
# **Hinweis**
Bei der Intertierung, wird...
- der Wert`1` zu  `5`
- der Wert `2` zu `4`
- der Wert `3`bleibt `3`
- der Wert `4` zu `2`
- der Wert `5` zu `1`

Die oben vorgstellte **Alternative 1** basiert auf der Annahme **"maximaler Skalenwert" + 1 - "Skalenwert der Person"**.
:::

# Alternative 2

```{r}
#| echo: true

 df_diss<-df_diss|>
    mutate(hs04_inv = recode(hs04,
                             "1"=5,
                             "2"=4,
                             "3"=3,
                             "4"=2,
                             "5"=1),
           hs05_inv = recode(hs05,
                             "1"=5,
                             "2"=4,
                             "3"=3,
                             "4"=2,
                             "5"=1),
           hs09_inv = recode(hs09,
                            "1"=5,
                            "2"=4,
                            "3"=3,
                            "4"=2,
                            "5"=1),
           )

head(df_diss, 10)           
```

# Alternative 3

```{r}
#| echo: true
#| warning: false
#| eval: false

install.packages("sjmisc")

```
```{r}
#| echo: true
#| warning: false

library(sjmisc)

df_diss <- df_diss|>
            mutate(hs04_inv = rec(hs04, rec = "rev"),
                  hs05_inv = rec(hs05, rec = "rev"),
                  hs09_inv = rec(hs09, rec = "rev")
                  )

head(df_diss, 10)

```
:::{.callout-tip collapse="true"}
# **Hinweis**
Wir haben hier einen Befehl aus einem anderen Paket genutzt. Wie du sehen kannst, sind Pakete auch miteinander kombinierbar!

Hier handelt es sich um den `rec()` Befehl aus dem Paket **sjmisc**.
:::
:::



## Umkodieren von Gruppen und Faktoren

Bisher haben wir Variablen umkodiert, die **numerisch skaliert** sind  
(z. B. Zustimmungsskalen von 1 bis 5).

In der Praxis arbeiten wir jedoch sehr h√§ufig auch mit **kategorialen Variablen**,  
zum Beispiel:
- Geschlecht  
- Bildungsabschluss  
- Wohnort  
- Erwerbsstatus  

Diese Variablen sind meist als **Faktoren** kodiert oder sollen als solche behandelt werden.

Beim Umkodieren von Faktorvariablen geht es weniger um Rechnen,  
sondern darum, **Kategorien sinnvoll zusammenzufassen oder neu zu benennen**.

In diesem Abschnitt schauen wir uns daher an,
wie wir **Faktorvariablen gezielt umkodieren**,  
zum Beispiel indem wir:
- mehrere Kategorien zu einer Gruppe zusammenfassen oder  
- neue, besser interpretierbare Gruppen bilden.

___

Wir erstellen nun erneut einen Datensatz und nennen es `df_rec`. Diesmal f√ºgen wir zu unseren Disstress Variablen weitere hinzu. Folgende Variablen sollen hinzugenommen werden:
- `gs01` - Selbsbeschreibung des Wohnorts
- `educ` - Allgemeiner Schulabschluss
- `mstat` - Familienstand
- `im17` bis `im21` - Einstellung zur sozialen Ungleichheit

:::{.callout-important collapse="true"}
# **Beschreibungen der Variablen**

:::{.panel-tabset}
# Wohnort
|**Variable**|**Inhalt**|**Skalierung**|
|----|----|----|
|gs01|"Selbsbeschreibung des Wohnorts"| 1 = Gro√üstadt<br> 2 = Vorort Gro√üstadt<br> 3 = Mittel-/Kleinstadt<br> 4 = l√§ndl. Dorf<br> 5 = Allein stehendes Haus auf dem Land |

# Schulabschluss
|**Variable**|**Inhalt**|**Skalierung**|
|----|----|----|
|educ|"Allgemeiner Schulabschluss"| 1 = Ohne Abschluss<br> 2 = Volks-/Hauptschule<br> 3 = Mittelere Reife<br> 4 = Fachhochschulreife<br> 5 = Hochschulreife<br> 6 = Anderer Abschluss<br> 7 = Noch Sch√ºler*in |

# Familienstand
|**Variable**|**Inhalt**|**Skalierung**|
|----|----|----|
|mstat|"Familienstand"| 1 = Verheiratet (zsm.lebend)<br> 2 = Verheiratet (getrennt)<br> 3 = Verwitwet<br> 4 = Geschieden<br> 5 = Ledig<br> 6 = Lebensp. (zsm.lebend)<br> 7 = Lebensp. (getrennt)<br> 8 = Lebensp. verstorben<br> Lebensp. aufgehoben |

# Soziale Ungleichheit
|**Variable**|**Inhalt**|**Skalierung**|
|----|----|----|
|im17|"Was man im Leben bekommt, h√§ngt gar nicht so sehr von den eigenen Anstrengungen ab, sondern von der Wirtschaftslage, der Lage auf dem Arbeitsmarkt, den Tarifabschl√ºssen und den Sozialleistungen des Staates."| 1 = "Stimme voll zu" bis 4 = "Stimme √ºberhaupt nicht zu"|
|im18|"Das Einkommen sollte sich nicht allein nach der Leistung des Einzelnen richten. Vielmehr sollte jeder das haben, was er mit seiner Familie f√ºr ein anst√§ndiges Leben braucht."| 1 = "Stimme voll zu" bis 4 = "Stimme √ºberhaupt nicht zu"|
|im19|"Nur wenn die Unterschiede im Einkommen und im sozialen Ansehen gro√ü genug sind, gibt es auch einen Anreiz f√ºr pers√∂nliche Leistungen."|1 = "Stimme voll zu" bis 4 = "Stimme √ºberhaupt nicht zu"|
|im20|"Die Rangunterschiede zwischen den Menschen sind akzeptabel, weil sie im Wesentlichen ausdr√ºcken, was man aus den Chancen, die man hatte, gemacht hat."| 1 = "Stimme voll zu" bis 4 = "Stimme √ºberhaupt nicht zu"|
|im21|"Ich finde die sozialen Unterschiede in unserem Land im Gro√üen und Ganzen gerecht."|1 = "Stimme voll zu" bis 4 = "Stimme √ºberhaupt nicht zu"|

:::
:::

:::{.callout-tip collapse="true"}
# L√∂sung
```{r}
#| echo: true
#| warning: false

library(tidyverse)

df_rec<-df_csv|>
  select(gs01,educ,mstat,
         hs04,hs05,hs06,hs07,hs09,
         im17,im18,im19,im20,im21)

head(df_rec, 10)
```
:::

Nun schauen wir uns die Umkodierung von Faktoren am Beispiel des Schulabschlusses an:

:::{.panel-tabset}
# Alternative 1
```{r}

df_rec <- df_rec |>
  mutate(
    wohnort = recode(
      gs01,
      "1"= 1,
      "2" = 1,
      "3" = 1,
      "4" = 2,
      "5" = 2
    ))

head(df_rec, 10)

```
:::{.callout-note collapse="true"}
# Beschreibung
Wir haben nun hier aus f√ºnf Gruppen zwei Gruppen gemacht. Wir unterscheiden nun zwischen **1 = Urban** und **2 = Rural**.
:::

# Alternative 2
```{r}

df_rec <- df_rec |>
  mutate(
    wohnort2 = factor(
      wohnort,
      levels = c(1, 2),
      labels = c("Urban", "Rural")
    )
  )

head(df_rec,10)

```
::: {.callout-note collapse="true"}
# Beschreibung
Wir haben hier die zuvor erstellten Gruppen (`1` und `2`) nun als **Faktor mit Labeln** gemacht.
:::

# Alternative 3
```{r}

df_rec <- df_rec |>
  mutate(
    wohnort3 = recode(
      gs01,
      "1" = 1,
      "2" = 1,
      "3" = 1,
      "4" = 2,
      "5" = 2
    ) |> factor(labels = c("Urban", "Rural"))
  )

head(df_rec, 10)

```
:::{.callout-note collapse="true"}
# Beschreibung
Hier haben wir es in einem Schritt getan.
:::

# Alternative 4

```{r}

df_rec <- df_rec |>
  mutate(
    wohnort4 = recode(
      gs01,
      "1" = "Urban",
      "2" = "Urban",
      "3" = "Urban",
      "4" = "Rural",
      "5" = "Rural"
    ) |> factor(levels = c("Urban", "Rural"))
  )

head(df_rec, 10)

```
:::{.callout-note collapse="true"}
# Beschreibung
Hier haben wir erst "gelabled" und dann Levels hinzugef√ºgt.
:::
:::

## √úbung

Schaut euch die Variablen im neuen Datensatz `df_rec` an. Eure Aufgabe ist es nun neue Variablen zu erstellen, die sinnvoll sind und die wir dann weiter nutzen werden.

1. Erstellt eine neue Variable von `educ` (nennt diese `abschluss`) die vierstufig ist (niedriger, mittlere, hoher und anderer)
2. Erstellt einen Skalenwert f√ºr Disstress und Soziale Unterst√ºtzung. Achtet darauf, dass der Summenwert sinnvol interpretierbar ist.

:::{.callout-tip collapse="true"}
# Tipp

- Schaut euch das Codebuch genauer an, um die Variablen besser zu verstehen.
- Guckt euch nochmal die Skalierung der Skalenitems an!
:::

::: {.callout-tip collapse="true"}
# **L√∂sung**

:::{.panel-tabset}

# Abschluss

```{r}

df_rec <- df_rec |>
  mutate(
    abschluss = recode(
      educ,
      "1" = 1,
      "2" = 1,
      "3" = 2,
      "4" = 3,
      "5" = 3,
      "6" = 4,
      "7" = 1
    ) |> factor(labels = c("Niedriger", "Mittlerer", "Hoher", "Anderer"))
  )

df_rec |>
  select(educ, abschluss) |>
  head(10)


```

# Disstress

```{r}
#| echo: true
#| waring: false

library(sjmisc)

df_rec<-df_rec|>
  mutate(
    hs04_r = rec(hs04, rec = "rev"),
    hs05_r = rec(hs05, rec = "rev"),
    hs09_r = rec(hs09, rec = "rev"),
    disstress = hs04_r + hs05_r + hs06 + hs07+ hs09_r
  )

df_rec |>
  select(hs04, hs04_r, hs05, hs05_r, hs06, hs07, hs09, hs09_r, disstress)|>
  head(10)

```

# Soziale Ungleichheit

```{r}
#| echo: true
#| warning: false

df_rec<-df_rec|>
  mutate(
    im17_r = 5 - im17,
    im18_r = 5 - im18,
    im19_r = 5 - im19,
    im20_r = 5 - im20,
    im21_r = 5 - im21,
    soz.u = rowSums(cbind(im17_r,im18_r,im19_r,im20_r,im21_r))
  )

df_rec |>
  select(im17:im21, im17_r:im21_r, soz.u) |>
  head(10)

```

# Alles in einem Schritt

```{r}
#| echo: true
#| warning: false

df_rec<-df_rec|>
  mutate(
    abschluss = recode(
      educ,
      "1" = 1,
      "2" = 1,
      "3" = 2,
      "4" = 3,
      "5" = 3,
      "6" = 4,
      "7" = 1
    ) |> factor(labels = c("Niedriger", "Mittlerer", "Hoher", "Anderer")),
    hs04_r = rec(hs04, rec = "rev"),
    hs05_r = rec(hs05, rec = "rev"),
    hs09_r = rec(hs09, rec = "rev"),
    distress = hs04_r + hs05_r + hs06 + hs07+ hs09_r,
    im17_r = 5 - im17,
    im18_r = 5 - im18,
    im19_r = 5 - im19,
    im20_r = 5 - im20,
    im21_r = 5 - im21,
    soz.u = rowSums(cbind(im17_r,im18_r,im19_r,im20_r,im21_r))
  )

df_rec |>
  select(abschluss, disstress, soz.u) |>
  head(10)

```
:::

:::



# Fehlende Werte (NA)

Warum fehlende Werte wichtig sind, wie man sie erkennt und sinnvoll behandelt.

___

# Umkodieren

Wie wir Variablen neu kodieren (z. B. Kategorien zusammenfassen, Werte umdrehen, Skalen bilden).

___

# Joins

Wie wir Datens√§tze √ºber eine gemeinsame ID zusammenf√ºhren (z. B. `left_join()`).

___

# Reproduzierbare Workflows

Ordnerstruktur, Skripte, klare Dateinamen, Outputs ‚Äì damit Analysen nachvollziehbar bleiben.

___

# Mini-Projekt

Wir kombinieren alles: Import ‚Üí Check ‚Üí Missing ‚Üí Recodes ‚Üí Join ‚Üí Export.
